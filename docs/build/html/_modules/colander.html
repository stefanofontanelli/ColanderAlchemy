

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>colander &mdash; ColanderAlchemy 0.1 documentation</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="ColanderAlchemy 0.1 documentation" href="../index.html" />
    <link rel="up" title="Module code" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../index.html">ColanderAlchemy 0.1 documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for colander</h1><div class="highlight"><pre>
<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">import</span> <span class="nn">decimal</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">iso8601</span>
<span class="kn">import</span> <span class="nn">pprint</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">translationstring</span>

<span class="n">_</span> <span class="o">=</span> <span class="n">translationstring</span><span class="o">.</span><span class="n">TranslationStringFactory</span><span class="p">(</span><span class="s">&#39;colander&#39;</span><span class="p">)</span>

<span class="n">required</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>
<span class="n">_marker</span> <span class="o">=</span> <span class="n">required</span> <span class="c"># bw compat</span>

<span class="k">class</span> <span class="nc">_null</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Represents a null value in colander-related operations. &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__nonzero__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;&lt;colander.null&gt;&#39;</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;null&#39;</span> <span class="c"># when unpickled, refers to &quot;null&quot; below (singleton)</span>

<span class="n">null</span> <span class="o">=</span> <span class="n">_null</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">interpolate</span><span class="p">(</span><span class="n">msgs</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">msgs</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&#39;interpolate&#39;</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">s</span><span class="o">.</span><span class="n">interpolate</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">s</span>

<div class="viewcode-block" id="Invalid"><a class="viewcode-back" href="../api.html#colander.Invalid">[docs]</a><span class="k">class</span> <span class="nc">Invalid</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An exception raised by data types and validators indicating that</span>
<span class="sd">    the value for a particular node was not valid.</span>

<span class="sd">    The constructor receives a mandatory ``node`` argument.  This must</span>
<span class="sd">    be an instance of the :class:`colander.SchemaNode` class, or at</span>
<span class="sd">    least something with the same interface.</span>

<span class="sd">    The constructor also receives an optional ``msg`` keyword</span>
<span class="sd">    argument, defaulting to ``None``.  The ``msg`` argument is a</span>
<span class="sd">    freeform field indicating the error circumstance.</span>

<span class="sd">    The constructor additionally may receive an optional ``value``</span>
<span class="sd">    keyword, indicating the value related to the error.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">positional</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="ne">Exception</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node</span> <span class="o">=</span> <span class="n">node</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="p">[]</span>

<div class="viewcode-block" id="Invalid.messages"><a class="viewcode-back" href="../api.html#colander.Invalid.messages">[docs]</a>    <span class="k">def</span> <span class="nf">messages</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return an iterable of error messages for this exception</span>
<span class="sd">        using the ``msg`` attribute of this error node.  If the</span>
<span class="sd">        ``msg`` attribute is iterable, it is returned.  If it is not</span>
<span class="sd">        iterable, a single-element list containing the ``msg`` value</span>
<span class="sd">        is returned.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msg</span><span class="p">,</span> <span class="s">&#39;__iter__&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">msg</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">msg</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="Invalid.add"><a class="viewcode-back" href="../api.html#colander.Invalid.add">[docs]</a>    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Add a child exception; ``exc`` must be an instance of</span>
<span class="sd">        :class:`colander.Invalid` or a subclass.</span>

<span class="sd">        ``pos`` is a value important for accurate error reporting.  If</span>
<span class="sd">        it is provided, it must be an integer representing the</span>
<span class="sd">        position of ``exc`` relative to all other subexceptions of</span>
<span class="sd">        this exception node.  For example, if the exception being</span>
<span class="sd">        added is about the third child of the exception which is</span>
<span class="sd">        ``self``, ``pos`` might be passed as ``3``.</span>

<span class="sd">        If ``pos`` is provided, it will be assigned to the ``pos``</span>
<span class="sd">        attribute of the provided ``exc`` object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">typ</span><span class="p">,</span> <span class="n">Positional</span><span class="p">):</span>
            <span class="n">exc</span><span class="o">.</span><span class="n">positional</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">exc</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">pos</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Add a subexception related to a child node with the</span>
<span class="sd">        message ``msg``. ``name`` must be present in the names of the</span>
<span class="sd">        set of child nodes of this exception&#39;s node; if this is not</span>
<span class="sd">        so, a :exc:`KeyError` is raised.</span>

<span class="sd">        For example, if the exception upon which ``__setitem__`` is</span>
<span class="sd">        called has a node attribute, and that node attribute has</span>
<span class="sd">        children that have the names ``name`` and ``title``, you may</span>
<span class="sd">        successfully call ``__setitem__(&#39;name&#39;, &#39;Bad name&#39;)`` or</span>
<span class="sd">        ``__setitem__(&#39;title&#39;, &#39;Bad title&#39;)``.  But calling</span>
<span class="sd">        ``__setitem__(&#39;wrong&#39;, &#39;whoops&#39;)`` will result in a</span>
<span class="sd">        :exc:`KeyError`.</span>

<span class="sd">        This method is typically only useful if the ``node`` attribute</span>
<span class="sd">        of the exception upon which it is called is a schema node</span>
<span class="sd">        representing a mapping.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">num</span><span class="p">,</span> <span class="n">child</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">name</span><span class="p">:</span>
                <span class="n">exc</span> <span class="o">=</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">exc</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>
                <span class="k">return</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

<div class="viewcode-block" id="Invalid.paths"><a class="viewcode-back" href="../api.html#colander.Invalid.paths">[docs]</a>    <span class="k">def</span> <span class="nf">paths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; A generator which returns each path through the exception</span>
<span class="sd">        graph.  Each path is represented as a tuple of exception</span>
<span class="sd">        nodes.  Within each tuple, the leftmost item will represent</span>
<span class="sd">        the root schema node, the rightmost item will represent the</span>
<span class="sd">        leaf schema node.&quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">stack</span><span class="p">):</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                <span class="k">yield</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">traverse</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">stack</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="n">path</span>

            <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">traverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">[])</span>
</div>
    <span class="k">def</span> <span class="nf">_keyname</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">positional</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

<div class="viewcode-block" id="Invalid.asdict"><a class="viewcode-back" href="../api.html#colander.Invalid.asdict">[docs]</a>    <span class="k">def</span> <span class="nf">asdict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return a dictionary containing a basic</span>
<span class="sd">        (non-language-translated) error report for this exception&quot;&quot;&quot;</span>
        <span class="n">paths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">()</span>
        <span class="n">errors</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">:</span>
            <span class="n">keyparts</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">msgs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">exc</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
                <span class="n">exc</span><span class="o">.</span><span class="n">msg</span> <span class="ow">and</span> <span class="n">msgs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">exc</span><span class="o">.</span><span class="n">msg</span><span class="p">)</span>
                <span class="n">keyname</span> <span class="o">=</span> <span class="n">exc</span><span class="o">.</span><span class="n">_keyname</span><span class="p">()</span>
                <span class="n">keyname</span> <span class="ow">and</span> <span class="n">keyparts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">keyname</span><span class="p">)</span>
            <span class="n">errors</span><span class="p">[</span><span class="s">&#39;.&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">keyparts</span><span class="p">)]</span> <span class="o">=</span> <span class="s">&#39;; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">interpolate</span><span class="p">(</span><span class="n">msgs</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">errors</span>
</div>
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return a pretty-formatted string representation of the</span>
<span class="sd">        result of an execution of this exception&#39;s ``asdict`` method&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">pprint</span><span class="o">.</span><span class="n">pformat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">asdict</span><span class="p">())</span>
</div>
<div class="viewcode-block" id="All"><a class="viewcode-back" href="../api.html#colander.All">[docs]</a><span class="k">class</span> <span class="nc">All</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Composite validator which succeeds if none of its</span>
<span class="sd">    subvalidators raises an :class:`colander.Invalid` exception&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">validators</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">validators</span> <span class="o">=</span> <span class="n">validators</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">msgs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">validator</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">validators</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">validator</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">Invalid</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">msgs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">msgs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">msgs</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Function"><a class="viewcode-back" href="../api.html#colander.Function">[docs]</a><span class="k">class</span> <span class="nc">Function</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Validator which accepts a function and an optional message;</span>
<span class="sd">    the function is called with the ``value`` during validation.</span>

<span class="sd">    If the function returns anything falsy (``None``, ``False``, the</span>
<span class="sd">    empty string, ``0``, an object with a ``__nonzero__`` that returns</span>
<span class="sd">    ``False``, etc) when called during validation, an</span>
<span class="sd">    :exc:`colander.Invalid` exception is raised (validation fails);</span>
<span class="sd">    its msg will be the value of the ``message`` argument passed to</span>
<span class="sd">    this class&#39; constructor.</span>

<span class="sd">    If the function returns a stringlike object (a ``str`` or</span>
<span class="sd">    ``unicode`` object) that is *not* the empty string , a</span>
<span class="sd">    :exc:`colander.Invalid` exception is raised using the stringlike</span>
<span class="sd">    value returned from the function as the exeption message</span>
<span class="sd">    (validation fails).</span>

<span class="sd">    If the function returns anything *except* a stringlike object</span>
<span class="sd">    object which is truthy (e.g. ``True``, the integer ``1``, an</span>
<span class="sd">    object with a ``__nonzero__`` that returns ``True``, etc), an</span>
<span class="sd">    :exc:`colander.Invalid` exception is *not* raised (validation</span>
<span class="sd">    succeeds).</span>

<span class="sd">    The default value for the ``message`` when not provided via the</span>
<span class="sd">    constructor is ``Invalid value``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="n">_</span><span class="p">(</span><span class="s">&#39;Invalid value&#39;</span><span class="p">)):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">message</span> <span class="o">=</span> <span class="n">message</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">message</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Regex"><a class="viewcode-back" href="../api.html#colander.Regex">[docs]</a><span class="k">class</span> <span class="nc">Regex</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Regular expression validator.</span>

<span class="sd">        Initialize it with the string regular expression ``regex``</span>
<span class="sd">        that will be compiled and matched against ``value`` when</span>
<span class="sd">        validator is called. If ``msg`` is supplied, it will be the</span>
<span class="sd">        error message to be used; otherwise, defaults to &#39;String does</span>
<span class="sd">        not match expected pattern&#39;.</span>

<span class="sd">        The ``regex`` argument may also be a pattern object (the</span>
<span class="sd">        result of ``re.compile``) instead of a string.</span>

<span class="sd">        When calling, if ``value`` matches the regular expression,</span>
<span class="sd">        validation succeeds; otherwise, :exc:`colander.Invalid` is</span>
<span class="sd">        raised with the ``msg`` error message.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">regex</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">regex</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">match_object</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">regex</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">match_object</span> <span class="o">=</span> <span class="n">regex</span>
        <span class="k">if</span> <span class="n">msg</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">msg</span> <span class="o">=</span> <span class="n">_</span><span class="p">(</span><span class="s">&quot;String does not match expected pattern&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">match_object</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">msg</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Email"><a class="viewcode-back" href="../api.html#colander.Email">[docs]</a><span class="k">class</span> <span class="nc">Email</span><span class="p">(</span><span class="n">Regex</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Email address validator. If ``msg`` is supplied, it will be</span>
<span class="sd">        the error message to be used when raising :exc:`colander.Invalid`;</span>
<span class="sd">        otherwise, defaults to &#39;Invalid email address&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">msg</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="n">_</span><span class="p">(</span><span class="s">&quot;Invalid email address&quot;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Email</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span>
            <span class="s">u&#39;(?i)^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,4}$&#39;</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="n">msg</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Range"><a class="viewcode-back" href="../api.html#colander.Range">[docs]</a><span class="k">class</span> <span class="nc">Range</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Validator which succeeds if the value it is passed is greater</span>
<span class="sd">    or equal to ``min`` and less than or equal to ``max``.  If ``min``</span>
<span class="sd">    is not specified, or is specified as ``None``, no lower bound</span>
<span class="sd">    exists.  If ``max`` is not specified, or is specified as ``None``,</span>
<span class="sd">    no upper bound exists.</span>

<span class="sd">    ``min_err`` is used to form the ``msg`` of the</span>
<span class="sd">    :exc:`colander.Invalid` error when reporting a validation failure</span>
<span class="sd">    caused by a value not meeting the minimum.  If ``min_err`` is</span>
<span class="sd">    specified, it must be a string.  The string may contain the</span>
<span class="sd">    replacement targets ``${min}`` and ``${val}``, representing the</span>
<span class="sd">    minimum value and the provided value respectively.  If it is not</span>
<span class="sd">    provided, it defaults to ``&#39;${val} is less than minimum value</span>
<span class="sd">    ${min}&#39;``.</span>

<span class="sd">    ``max_err`` is used to form the ``msg`` of the</span>
<span class="sd">    :exc:`colander.Invalid` error when reporting a validation failure</span>
<span class="sd">    caused by a value exceeding the maximum.  If ``max_err`` is</span>
<span class="sd">    specified, it must be a string.  The string may contain the</span>
<span class="sd">    replacement targets ``${max}`` and ``${val}``, representing the</span>
<span class="sd">    maximum value and the provided value respectively.  If it is not</span>
<span class="sd">    provided, it defaults to ``&#39;${val} is greater than maximum value</span>
<span class="sd">    ${max}&#39;``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">min_err</span> <span class="o">=</span> <span class="n">_</span><span class="p">(</span><span class="s">&#39;${val} is less than minimum value ${min}&#39;</span><span class="p">)</span>
    <span class="n">max_err</span> <span class="o">=</span> <span class="n">_</span><span class="p">(</span><span class="s">&#39;${val} is greater than maximum value ${max}&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">min_err</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">max_err</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min</span> <span class="o">=</span> <span class="nb">min</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max</span> <span class="o">=</span> <span class="nb">max</span>
        <span class="k">if</span> <span class="n">min_err</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">min_err</span> <span class="o">=</span> <span class="n">min_err</span>
        <span class="k">if</span> <span class="n">max_err</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_err</span> <span class="o">=</span> <span class="n">max_err</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">min</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">min</span><span class="p">:</span>
                <span class="n">min_err</span> <span class="o">=</span> <span class="n">_</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_err</span><span class="p">,</span> <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;val&#39;</span><span class="p">:</span><span class="n">value</span><span class="p">,</span> <span class="s">&#39;min&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">min</span><span class="p">})</span>
                <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">min_err</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max</span><span class="p">:</span>
                <span class="n">max_err</span> <span class="o">=</span> <span class="n">_</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_err</span><span class="p">,</span> <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;val&#39;</span><span class="p">:</span><span class="n">value</span><span class="p">,</span> <span class="s">&#39;max&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">max</span><span class="p">})</span>
                <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">max_err</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Length"><a class="viewcode-back" href="../api.html#colander.Length">[docs]</a><span class="k">class</span> <span class="nc">Length</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Validator which succeeds if the value passed to it has a</span>
<span class="sd">    length between a minimum and maximum.  The value is most often a</span>
<span class="sd">    string.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min</span> <span class="o">=</span> <span class="nb">min</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max</span> <span class="o">=</span> <span class="nb">max</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">min</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">min</span><span class="p">:</span>
                <span class="n">min_err</span> <span class="o">=</span> <span class="n">_</span><span class="p">(</span><span class="s">&#39;Shorter than minimum length ${min}&#39;</span><span class="p">,</span>
                            <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;min&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">min</span><span class="p">})</span>
                <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">min_err</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max</span><span class="p">:</span>
                <span class="n">max_err</span> <span class="o">=</span> <span class="n">_</span><span class="p">(</span><span class="s">&#39;Longer than maximum length ${max}&#39;</span><span class="p">,</span>
                            <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;max&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">max</span><span class="p">})</span>
                <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">max_err</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="OneOf"><a class="viewcode-back" href="../api.html#colander.OneOf">[docs]</a><span class="k">class</span> <span class="nc">OneOf</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Validator which succeeds if the value passed to it is one of</span>
<span class="sd">    a fixed set of values &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">choices</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">choices</span> <span class="o">=</span> <span class="n">choices</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">choices</span><span class="p">:</span>
            <span class="n">choices</span> <span class="o">=</span> <span class="s">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">choices</span><span class="p">])</span>
            <span class="n">err</span> <span class="o">=</span> <span class="n">_</span><span class="p">(</span><span class="s">&#39;&quot;${val}&quot; is not one of ${choices}&#39;</span><span class="p">,</span>
                    <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;val&#39;</span><span class="p">:</span><span class="n">value</span><span class="p">,</span> <span class="s">&#39;choices&#39;</span><span class="p">:</span><span class="n">choices</span><span class="p">})</span>
            <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
</div>
<span class="k">class</span> <span class="nc">SchemaType</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Base class for all schema types &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">flatten</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">,</span> <span class="n">listitem</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">listitem</span><span class="p">:</span>
            <span class="n">selfname</span> <span class="o">=</span> <span class="n">prefix</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">selfname</span> <span class="o">=</span> <span class="s">&#39;</span><span class="si">%s%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="n">result</span><span class="p">[</span><span class="n">selfname</span><span class="p">]</span> <span class="o">=</span> <span class="n">appstruct</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">unflatten</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">paths</span><span class="p">,</span> <span class="n">fstruct</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span>
        <span class="k">assert</span> <span class="n">paths</span> <span class="o">==</span> <span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="s">&quot;paths should be [name] for leaf nodes.&quot;</span>
        <span class="k">return</span> <span class="n">fstruct</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">set_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s">&quot;Can&#39;t call &#39;set_value&#39; on a leaf node.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s">&quot;Can&#39;t call &#39;set_value&#39; on a leaf node.&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="Mapping"><a class="viewcode-back" href="../api.html#colander.Mapping">[docs]</a><span class="k">class</span> <span class="nc">Mapping</span><span class="p">(</span><span class="n">SchemaType</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; A type which represents a mapping of names to nodes.</span>

<span class="sd">    The subnodes of the :class:`colander.SchemaNode` that wraps</span>
<span class="sd">    this type imply the named keys and values in the mapping.</span>

<span class="sd">    The constructor of this type accepts one extra optional keyword</span>
<span class="sd">    argument that other types do not: ``unknown``.  An attribute of</span>
<span class="sd">    the same name can be set on a type instance to control the</span>
<span class="sd">    behavior after construction.</span>

<span class="sd">    unknown</span>
<span class="sd">        ``unknown`` controls the behavior of this type when an unknown</span>
<span class="sd">        key is encountered in the cstruct passed to the</span>
<span class="sd">        ``deserialize`` method of this instance.  All the potential</span>
<span class="sd">        values of ``unknown`` are strings.  They are:</span>

<span class="sd">        - ``ignore`` means that keys that are not present in the schema</span>
<span class="sd">          associated with this type will be ignored during</span>
<span class="sd">          deserialization.</span>

<span class="sd">        - ``raise`` will cause a :exc:`colander.Invalid` exception to</span>
<span class="sd">          be raised when unknown keys are present in the cstruct</span>
<span class="sd">          during deserialization.</span>

<span class="sd">        - ``preserve`` will preserve the &#39;raw&#39; unknown keys and values</span>
<span class="sd">          in the appstruct returned by deserialization.</span>

<span class="sd">        Default: ``ignore``.</span>

<span class="sd">    Special behavior is exhibited when a subvalue of a mapping is</span>
<span class="sd">    present in the schema but is missing from the mapping passed to</span>
<span class="sd">    either the ``serialize`` or ``deserialize`` method of this class.</span>
<span class="sd">    In this case, the :attr:`colander.null` value will be passed to</span>
<span class="sd">    the ``serialize`` or ``deserialize`` method of the schema node</span>
<span class="sd">    representing the subvalue of the mapping respectively.  During</span>
<span class="sd">    serialization, this will result in the behavior described in</span>
<span class="sd">    :ref:`serializing_null` for the subnode.  During deserialization,</span>
<span class="sd">    this will result in the behavior described in</span>
<span class="sd">    :ref:`deserializing_null` for the subnode.</span>

<span class="sd">    If the :attr:`colander.null` value is passed to the serialize</span>
<span class="sd">    method of this class, a dictionary will be returned, where each of</span>
<span class="sd">    the values in the returned dictionary is the serialized</span>
<span class="sd">    representation of the null value for its type.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unknown</span><span class="o">=</span><span class="s">&#39;ignore&#39;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unknown</span> <span class="o">=</span> <span class="n">unknown</span>

    <span class="k">def</span> <span class="nf">_set_unknown</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">value</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;ignore&#39;</span><span class="p">,</span> <span class="s">&#39;raise&#39;</span><span class="p">,</span> <span class="s">&#39;preserve&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s">&#39;unknown attribute must be one of &quot;ignore&quot;, &quot;raise&quot;, &#39;</span>
                <span class="s">&#39;or &quot;preserve&quot;&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unknown</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">_get_unknown</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unknown</span>

    <span class="n">unknown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_unknown</span><span class="p">,</span> <span class="n">_set_unknown</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_validate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">node</span><span class="p">,</span>
                          <span class="n">_</span><span class="p">(</span><span class="s">&#39;&quot;${val}&quot; is not a mapping type: ${err}&#39;</span><span class="p">,</span>
                          <span class="n">mapping</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;val&#39;</span><span class="p">:</span><span class="n">value</span><span class="p">,</span> <span class="s">&#39;err&#39;</span><span class="p">:</span><span class="n">e</span><span class="p">})</span>
                          <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">callback</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="n">error</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">num</span><span class="p">,</span> <span class="n">subnode</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">):</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">subnode</span><span class="o">.</span><span class="n">name</span>
            <span class="n">subval</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">null</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">callback</span><span class="p">(</span><span class="n">subnode</span><span class="p">,</span> <span class="n">subval</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">Invalid</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">error</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">error</span> <span class="o">=</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="n">error</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">unknown</span> <span class="o">==</span> <span class="s">&#39;raise&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">value</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span>
                    <span class="n">node</span><span class="p">,</span>
                    <span class="n">_</span><span class="p">(</span><span class="s">&#39;Unrecognized keys in mapping: &quot;${val}&quot;&#39;</span><span class="p">,</span>
                      <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;val&#39;</span><span class="p">:</span><span class="n">value</span><span class="p">})</span>
                    <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">unknown</span> <span class="o">==</span> <span class="s">&#39;preserve&#39;</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">error</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">error</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">appstruct</span> <span class="ow">is</span> <span class="n">null</span><span class="p">:</span>
            <span class="n">appstruct</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">def</span> <span class="nf">callback</span><span class="p">(</span><span class="n">subnode</span><span class="p">,</span> <span class="n">subappstruct</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">subnode</span><span class="o">.</span><span class="n">serialize</span><span class="p">(</span><span class="n">subappstruct</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">,</span> <span class="n">callback</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">deserialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">cstruct</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cstruct</span> <span class="ow">is</span> <span class="n">null</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">null</span>

        <span class="k">def</span> <span class="nf">callback</span><span class="p">(</span><span class="n">subnode</span><span class="p">,</span> <span class="n">subcstruct</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">subnode</span><span class="o">.</span><span class="n">deserialize</span><span class="p">(</span><span class="n">subcstruct</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">cstruct</span><span class="p">,</span> <span class="n">callback</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">flatten</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">,</span> <span class="n">listitem</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">listitem</span><span class="p">:</span>
            <span class="n">selfprefix</span> <span class="o">=</span> <span class="n">prefix</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">selfprefix</span> <span class="o">=</span> <span class="s">&#39;</span><span class="si">%s%s</span><span class="s">.&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">subnode</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">subnode</span><span class="o">.</span><span class="n">name</span>
            <span class="n">substruct</span> <span class="o">=</span> <span class="n">appstruct</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">null</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">subnode</span><span class="o">.</span><span class="n">typ</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">subnode</span><span class="p">,</span> <span class="n">substruct</span><span class="p">,</span>
                                              <span class="n">prefix</span><span class="o">=</span><span class="n">selfprefix</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">unflatten</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">paths</span><span class="p">,</span> <span class="n">fstruct</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_unflatten_mapping</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">paths</span><span class="p">,</span> <span class="n">fstruct</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="s">&#39;.&#39;</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
            <span class="n">next_name</span><span class="p">,</span> <span class="n">rest</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">next_node</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="n">next_name</span><span class="p">]</span>
            <span class="n">next_appstruct</span> <span class="o">=</span> <span class="n">appstruct</span><span class="p">[</span><span class="n">next_name</span><span class="p">]</span>
            <span class="n">appstruct</span><span class="p">[</span><span class="n">next_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">next_node</span><span class="o">.</span><span class="n">typ</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span>
                <span class="n">next_node</span><span class="p">,</span> <span class="n">next_appstruct</span><span class="p">,</span> <span class="n">rest</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">appstruct</span><span class="p">[</span><span class="n">path</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">return</span> <span class="n">appstruct</span>

    <span class="k">def</span> <span class="nf">get_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="k">if</span> <span class="s">&#39;.&#39;</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
            <span class="n">name</span><span class="p">,</span> <span class="n">rest</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">next_node</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">next_node</span><span class="o">.</span><span class="n">typ</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="n">next_node</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="n">rest</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">appstruct</span><span class="p">[</span><span class="n">path</span><span class="p">]</span>

</div>
<span class="k">class</span> <span class="nc">Positional</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Marker abstract base class meaning &#39;this type has children which</span>
<span class="sd">    should be addressed by position instead of name&#39; (e.g. via seq[0],</span>
<span class="sd">    but never seq[&#39;name&#39;]).  This is consulted by Invalid.asdict when</span>
<span class="sd">    creating a dictionary representation of an error tree.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Tuple"><a class="viewcode-back" href="../api.html#colander.Tuple">[docs]</a><span class="k">class</span> <span class="nc">Tuple</span><span class="p">(</span><span class="n">Positional</span><span class="p">,</span> <span class="n">SchemaType</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; A type which represents a fixed-length sequence of nodes.</span>

<span class="sd">    The subnodes of the :class:`colander.SchemaNode` that wraps</span>
<span class="sd">    this type imply the positional elements of the tuple in the order</span>
<span class="sd">    they are added.</span>

<span class="sd">    This type is willing to serialize and deserialized iterables that,</span>
<span class="sd">    when converted to a tuple, have the same number of elements as the</span>
<span class="sd">    number of the associated node&#39;s subnodes.</span>

<span class="sd">    If the :attr:`colander.null` value is passed to the serialize</span>
<span class="sd">    method of this class, the :attr:`colander.null` value will be</span>
<span class="sd">    returned.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">_validate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s">&#39;__iter__&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span>
                <span class="n">node</span><span class="p">,</span>
                <span class="n">_</span><span class="p">(</span><span class="s">&#39;&quot;${val}&quot; is not iterable&#39;</span><span class="p">,</span> <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;val&#39;</span><span class="p">:</span><span class="n">value</span><span class="p">})</span>
                <span class="p">)</span>

        <span class="n">valuelen</span><span class="p">,</span> <span class="n">nodelen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">valuelen</span> <span class="o">!=</span> <span class="n">nodelen</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span>
                <span class="n">node</span><span class="p">,</span>
                <span class="n">_</span><span class="p">(</span><span class="s">&#39;&quot;${val}&quot; has an incorrect number of elements &#39;</span>
                  <span class="s">&#39;(expected ${exp}, was ${was})&#39;</span><span class="p">,</span>
                  <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;val&#39;</span><span class="p">:</span><span class="n">value</span><span class="p">,</span> <span class="s">&#39;exp&#39;</span><span class="p">:</span><span class="n">nodelen</span><span class="p">,</span> <span class="s">&#39;was&#39;</span><span class="p">:</span><span class="n">valuelen</span><span class="p">})</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">callback</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="n">error</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">num</span><span class="p">,</span> <span class="n">subnode</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">):</span>
            <span class="n">subval</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="n">num</span><span class="p">]</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">callback</span><span class="p">(</span><span class="n">subnode</span><span class="p">,</span> <span class="n">subval</span><span class="p">))</span>
            <span class="k">except</span> <span class="n">Invalid</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">error</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">error</span> <span class="o">=</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="n">error</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">error</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">error</span>

        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">appstruct</span> <span class="ow">is</span> <span class="n">null</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">null</span>

        <span class="k">def</span> <span class="nf">callback</span><span class="p">(</span><span class="n">subnode</span><span class="p">,</span> <span class="n">subappstruct</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">subnode</span><span class="o">.</span><span class="n">serialize</span><span class="p">(</span><span class="n">subappstruct</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">,</span> <span class="n">callback</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">deserialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">cstruct</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cstruct</span> <span class="ow">is</span> <span class="n">null</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">null</span>

        <span class="k">def</span> <span class="nf">callback</span><span class="p">(</span><span class="n">subnode</span><span class="p">,</span> <span class="n">subval</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">subnode</span><span class="o">.</span><span class="n">deserialize</span><span class="p">(</span><span class="n">subval</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">cstruct</span><span class="p">,</span> <span class="n">callback</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">flatten</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">,</span> <span class="n">listitem</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">listitem</span><span class="p">:</span>
            <span class="n">selfprefix</span> <span class="o">=</span> <span class="n">prefix</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">selfprefix</span> <span class="o">=</span> <span class="s">&#39;</span><span class="si">%s%s</span><span class="s">.&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">num</span><span class="p">,</span> <span class="n">subnode</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">):</span>
            <span class="n">substruct</span> <span class="o">=</span> <span class="n">appstruct</span><span class="p">[</span><span class="n">num</span><span class="p">]</span>
            <span class="n">result</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">subnode</span><span class="o">.</span><span class="n">typ</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">subnode</span><span class="p">,</span> <span class="n">substruct</span><span class="p">,</span>
                                              <span class="n">prefix</span><span class="o">=</span><span class="n">selfprefix</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">unflatten</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">paths</span><span class="p">,</span> <span class="n">fstruct</span><span class="p">):</span>
        <span class="n">mapstruct</span> <span class="o">=</span> <span class="n">_unflatten_mapping</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">paths</span><span class="p">,</span> <span class="n">fstruct</span><span class="p">)</span>
        <span class="n">appstruct</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">subnode</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="n">appstruct</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mapstruct</span><span class="p">[</span><span class="n">subnode</span><span class="o">.</span><span class="n">name</span><span class="p">])</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">appstruct</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">appstruct</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">appstruct</span><span class="p">)</span>
        <span class="k">if</span> <span class="s">&#39;.&#39;</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
            <span class="n">next_name</span><span class="p">,</span> <span class="n">rest</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">next_name</span><span class="p">,</span> <span class="n">rest</span> <span class="o">=</span> <span class="n">path</span><span class="p">,</span> <span class="bp">None</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">next_node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">next_node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">next_name</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">next_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rest</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">next_appstruct</span> <span class="o">=</span> <span class="n">appstruct</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="n">appstruct</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">next_node</span><span class="o">.</span><span class="n">typ</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span>
                <span class="n">next_node</span><span class="p">,</span> <span class="n">next_appstruct</span><span class="p">,</span> <span class="n">rest</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">appstruct</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">appstruct</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="k">if</span> <span class="s">&#39;.&#39;</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
            <span class="n">name</span><span class="p">,</span> <span class="n">rest</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">name</span><span class="p">,</span> <span class="n">rest</span> <span class="o">=</span> <span class="n">path</span><span class="p">,</span> <span class="bp">None</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">next_node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">next_node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">name</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rest</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">next_node</span><span class="o">.</span><span class="n">typ</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="n">next_node</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">rest</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">appstruct</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

</div>
<div class="viewcode-block" id="Sequence"><a class="viewcode-back" href="../api.html#colander.Sequence">[docs]</a><span class="k">class</span> <span class="nc">Sequence</span><span class="p">(</span><span class="n">Positional</span><span class="p">,</span> <span class="n">SchemaType</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A type which represents a variable-length sequence of nodes,</span>
<span class="sd">    all of which must be of the same type.</span>

<span class="sd">    The type of the first subnode of the</span>
<span class="sd">    :class:`colander.SchemaNode` that wraps this type is considered the</span>
<span class="sd">    sequence type.</span>

<span class="sd">    The optional ``accept_scalar`` argument to this type&#39;s constructor</span>
<span class="sd">    indicates what should happen if the value found during serialization or</span>
<span class="sd">    deserialization does not have an ``__iter__`` method or is a</span>
<span class="sd">    mapping type.</span>

<span class="sd">    If ``accept_scalar`` is ``True`` and the value does not have an</span>
<span class="sd">    ``__iter__`` method or is a mapping type, the value will be turned</span>
<span class="sd">    into a single element list.</span>

<span class="sd">    If ``accept_scalar`` is ``False`` and the value does not have an</span>
<span class="sd">    ``__iter__`` method or is a mapping type, an</span>
<span class="sd">    :exc:`colander.Invalid` error will be raised during serialization</span>
<span class="sd">    and deserialization.</span>

<span class="sd">    The default value of ``accept_scalar`` is ``False``.</span>

<span class="sd">    If the :attr:`colander.null` value is passed to the serialize</span>
<span class="sd">    method of this class, the :attr:`colander.null` value is returned.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">accept_scalar</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">accept_scalar</span> <span class="o">=</span> <span class="n">accept_scalar</span>

    <span class="k">def</span> <span class="nf">_validate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">accept_scalar</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s">&#39;__iter__&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s">&#39;get&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">accept_scalar</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">value</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">_</span><span class="p">(</span><span class="s">&#39;&quot;${val}&quot; is not iterable&#39;</span><span class="p">,</span>
                                  <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;val&#39;</span><span class="p">:</span><span class="n">value</span><span class="p">})</span>
                          <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="n">accept_scalar</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">accept_scalar</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">accept_scalar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">accept_scalar</span>

        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">accept_scalar</span><span class="p">)</span>

        <span class="n">error</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">num</span><span class="p">,</span> <span class="n">subval</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">callback</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">subval</span><span class="p">))</span>
            <span class="k">except</span> <span class="n">Invalid</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">error</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">error</span> <span class="o">=</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="n">error</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">error</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">error</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">,</span> <span class="n">accept_scalar</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Along with the normal ``node`` and ``appstruct`` arguments,</span>
<span class="sd">        this method accepts an additional optional keyword argument:</span>
<span class="sd">        ``accept_scalar``.  This keyword argument can be used to</span>
<span class="sd">        override the constructor value of the same name.</span>

<span class="sd">        If ``accept_scalar`` is ``True`` and the ``appstruct`` does</span>
<span class="sd">        not have an ``__iter__`` method or is a mapping type, the</span>
<span class="sd">        value will be turned into a single element list.</span>

<span class="sd">        If ``accept_scalar`` is ``False`` and the ``appstruct`` does</span>
<span class="sd">        not have an ``__iter__`` method or is a mapping type, an</span>
<span class="sd">        :exc:`colander.Invalid` error will be raised during</span>
<span class="sd">        serialization and deserialization.</span>

<span class="sd">        The default of ``accept_scalar`` is ``None``, which means</span>
<span class="sd">        respect the default ``accept_scalar`` value attached to this</span>
<span class="sd">        instance via its constructor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">appstruct</span> <span class="ow">is</span> <span class="n">null</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">null</span>

        <span class="k">def</span> <span class="nf">callback</span><span class="p">(</span><span class="n">subnode</span><span class="p">,</span> <span class="n">subappstruct</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">subnode</span><span class="o">.</span><span class="n">serialize</span><span class="p">(</span><span class="n">subappstruct</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="n">accept_scalar</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">deserialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">cstruct</span><span class="p">,</span> <span class="n">accept_scalar</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Along with the normal ``node`` and ``cstruct`` arguments, this</span>
<span class="sd">        method accepts an additional optional keyword argument:</span>
<span class="sd">        ``accept_scalar``.  This keyword argument can be used to</span>
<span class="sd">        override the constructor value of the same name.</span>

<span class="sd">        If ``accept_scalar`` is ``True`` and the ``cstruct`` does not</span>
<span class="sd">        have an ``__iter__`` method or is a mapping type, the value</span>
<span class="sd">        will be turned into a single element list.</span>

<span class="sd">        If ``accept_scalar`` is ``False`` and the ``cstruct`` does not have an</span>
<span class="sd">        ``__iter__`` method or is a mapping type, an</span>
<span class="sd">        :exc:`colander.Invalid` error will be raised during serialization</span>
<span class="sd">        and deserialization.</span>

<span class="sd">        The default of ``accept_scalar`` is ``None``, which means</span>
<span class="sd">        respect the default ``accept_scalar`` value attached to this</span>
<span class="sd">        instance via its constructor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">cstruct</span> <span class="ow">is</span> <span class="n">null</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">null</span>

        <span class="k">def</span> <span class="nf">callback</span><span class="p">(</span><span class="n">subnode</span><span class="p">,</span> <span class="n">subcstruct</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">subnode</span><span class="o">.</span><span class="n">deserialize</span><span class="p">(</span><span class="n">subcstruct</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">cstruct</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="n">accept_scalar</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">flatten</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">,</span> <span class="n">listitem</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">listitem</span><span class="p">:</span>
            <span class="n">selfprefix</span> <span class="o">=</span> <span class="n">prefix</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">selfprefix</span> <span class="o">=</span> <span class="s">&#39;</span><span class="si">%s%s</span><span class="s">.&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="n">childnode</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">num</span><span class="p">,</span> <span class="n">subval</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">appstruct</span><span class="p">):</span>
            <span class="n">subname</span> <span class="o">=</span> <span class="s">&#39;</span><span class="si">%s%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">selfprefix</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>
            <span class="n">subprefix</span> <span class="o">=</span> <span class="n">subname</span> <span class="o">+</span> <span class="s">&#39;.&#39;</span>
            <span class="n">result</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">childnode</span><span class="o">.</span><span class="n">typ</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span>
                <span class="n">childnode</span><span class="p">,</span> <span class="n">subval</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="n">subprefix</span><span class="p">,</span> <span class="n">listitem</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">unflatten</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">paths</span><span class="p">,</span> <span class="n">fstruct</span><span class="p">):</span>
        <span class="n">only_child</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">child_name</span> <span class="o">=</span> <span class="n">only_child</span><span class="o">.</span><span class="n">name</span>
        <span class="k">def</span> <span class="nf">get_child</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">only_child</span>
        <span class="k">def</span> <span class="nf">rewrite_subpath</span><span class="p">(</span><span class="n">subpath</span><span class="p">):</span>
            <span class="k">if</span> <span class="s">&#39;.&#39;</span> <span class="ow">in</span> <span class="n">subpath</span><span class="p">:</span>
                <span class="n">suffix</span> <span class="o">=</span> <span class="n">subpath</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">return</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">.</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">child_name</span><span class="p">,</span> <span class="n">suffix</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">child_name</span>
        <span class="n">mapstruct</span> <span class="o">=</span> <span class="n">_unflatten_mapping</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">paths</span><span class="p">,</span> <span class="n">fstruct</span><span class="p">,</span>
                                       <span class="n">get_child</span><span class="p">,</span> <span class="n">rewrite_subpath</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">mapstruct</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">index</span><span class="p">)]</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mapstruct</span><span class="p">))]</span>

    <span class="k">def</span> <span class="nf">set_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="s">&#39;.&#39;</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
            <span class="n">next_name</span><span class="p">,</span> <span class="n">rest</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">next_name</span><span class="p">)</span>
            <span class="n">next_node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">next_appstruct</span> <span class="o">=</span> <span class="n">appstruct</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="n">appstruct</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">next_node</span><span class="o">.</span><span class="n">typ</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span>
                <span class="n">next_node</span><span class="p">,</span> <span class="n">next_appstruct</span><span class="p">,</span> <span class="n">rest</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
            <span class="n">appstruct</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">return</span> <span class="n">appstruct</span>

    <span class="k">def</span> <span class="nf">get_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="k">if</span> <span class="s">&#39;.&#39;</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
            <span class="n">name</span><span class="p">,</span> <span class="n">rest</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="n">next_node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">next_node</span><span class="o">.</span><span class="n">typ</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="n">next_node</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">rest</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">appstruct</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">path</span><span class="p">)]</span>
</div>
<span class="n">Seq</span> <span class="o">=</span> <span class="n">Sequence</span>

<div class="viewcode-block" id="String"><a class="viewcode-back" href="../api.html#colander.String">[docs]</a><span class="k">class</span> <span class="nc">String</span><span class="p">(</span><span class="n">SchemaType</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; A type representing a Unicode string.</span>

<span class="sd">    This type constructor accepts one argument:</span>

<span class="sd">    ``encoding``</span>
<span class="sd">       Represents the encoding which should be applied to value</span>
<span class="sd">       serialization and deserialization, for example ``utf-8``.  If</span>
<span class="sd">       ``encoding`` is passed as ``None``, the ``serialize`` method of</span>
<span class="sd">       this type will not do any special encoding of the appstruct it is</span>
<span class="sd">       provided, nor will the ``deserialize`` method of this type do</span>
<span class="sd">       any special decoding of the cstruct it is provided; inputs and</span>
<span class="sd">       outputs will be assumed to be Unicode.  ``encoding`` defaults</span>
<span class="sd">       to ``None``.</span>

<span class="sd">       If ``encoding`` is ``None``:</span>

<span class="sd">       - A Unicode input value to ``serialize`` is returned untouched.</span>

<span class="sd">       - A non-Unicode input value to ``serialize`` is run through the</span>
<span class="sd">         ``unicode()`` function without an ``encoding`` parameter</span>
<span class="sd">         (``unicode(value)``) and the result is returned.</span>

<span class="sd">       - A Unicode input value to ``deserialize`` is returned untouched.</span>

<span class="sd">       - A non-Unicode input value to ``deserialize`` is run through the</span>
<span class="sd">         ``unicode()`` function without an ``encoding`` parameter</span>
<span class="sd">         (``unicode(value)``) and the result is returned.</span>

<span class="sd">       If ``encoding`` is not ``None``:</span>

<span class="sd">       - A Unicode input value to ``serialize`` is run through the</span>
<span class="sd">         ``unicode`` function with the encoding parameter</span>
<span class="sd">         (``unicode(value, encoding)``) and the result (a ``str``</span>
<span class="sd">         object) is returned.</span>

<span class="sd">       - A non-Unicode input value to ``serialize`` is converted to a</span>
<span class="sd">         Unicode using the encoding (``unicode(value, encoding)``);</span>
<span class="sd">         subsequently the Unicode object is reeencoded to a ``str``</span>
<span class="sd">         object using the encoding and returned.</span>

<span class="sd">       - A Unicode input value to ``deserialize`` is returned</span>
<span class="sd">         untouched.</span>

<span class="sd">       - A non-Unicode input value to ``deserialize`` is converted to</span>
<span class="sd">         a ``str`` object using ``str(value``).  The resulting str</span>
<span class="sd">         value is converted to Unicode using the encoding</span>
<span class="sd">         (``unicode(value, encoding)``) and the result is returned.</span>

<span class="sd">       A corollary: If a string (as opposed to a unicode object) is</span>
<span class="sd">       provided as a value to either the serialize or deserialize</span>
<span class="sd">       method of this type, and the type also has an non-None</span>
<span class="sd">       ``encoding``, the string must be encoded with the type&#39;s</span>
<span class="sd">       encoding.  If this is not true, an :exc:`colander.Invalid`</span>
<span class="sd">       error will result.</span>

<span class="sd">    The subnodes of the :class:`colander.SchemaNode` that wraps</span>
<span class="sd">    this type are ignored.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">encoding</span> <span class="o">=</span> <span class="n">encoding</span>

    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">appstruct</span> <span class="ow">is</span> <span class="n">null</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">null</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">appstruct</span><span class="p">,</span> <span class="nb">unicode</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">encoding</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">appstruct</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">encoding</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">appstruct</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">encoding</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">encoding</span>
                <span class="k">if</span> <span class="n">encoding</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="nb">unicode</span><span class="p">(</span><span class="n">appstruct</span><span class="p">,</span> <span class="n">encoding</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">encoding</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="nb">unicode</span><span class="p">(</span><span class="n">appstruct</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">node</span><span class="p">,</span>
                          <span class="n">_</span><span class="p">(</span><span class="s">&#39;&quot;${val} cannot be serialized: ${err}&#39;</span><span class="p">,</span>
                            <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;val&#39;</span><span class="p">:</span><span class="n">appstruct</span><span class="p">,</span> <span class="s">&#39;err&#39;</span><span class="p">:</span><span class="n">e</span><span class="p">})</span>
                          <span class="p">)</span>
    <span class="k">def</span> <span class="nf">deserialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">cstruct</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">cstruct</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">null</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">cstruct</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="nb">unicode</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">encoding</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="nb">unicode</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">cstruct</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">encoding</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="nb">unicode</span><span class="p">(</span><span class="n">cstruct</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">node</span><span class="p">,</span>
                          <span class="n">_</span><span class="p">(</span><span class="s">&#39;${val} is not a string: %{err}&#39;</span><span class="p">,</span>
                            <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;val&#39;</span><span class="p">:</span><span class="n">cstruct</span><span class="p">,</span> <span class="s">&#39;err&#39;</span><span class="p">:</span><span class="n">e</span><span class="p">}))</span>

        <span class="k">return</span> <span class="n">result</span>
</div>
<span class="n">Str</span> <span class="o">=</span> <span class="n">String</span>

<span class="k">class</span> <span class="nc">Number</span><span class="p">(</span><span class="n">SchemaType</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Abstract base class for float, int, decimal &quot;&quot;&quot;</span>

    <span class="n">num</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">appstruct</span> <span class="ow">is</span> <span class="n">null</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">null</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num</span><span class="p">(</span><span class="n">appstruct</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">node</span><span class="p">,</span>
                          <span class="n">_</span><span class="p">(</span><span class="s">&#39;&quot;${val}&quot; is not a number&#39;</span><span class="p">,</span>
                            <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;val&#39;</span><span class="p">:</span><span class="n">appstruct</span><span class="p">}),</span>
                          <span class="p">)</span>
    <span class="k">def</span> <span class="nf">deserialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">cstruct</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cstruct</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">cstruct</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">null</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num</span><span class="p">(</span><span class="n">cstruct</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">node</span><span class="p">,</span>
                          <span class="n">_</span><span class="p">(</span><span class="s">&#39;&quot;${val}&quot; is not a number&#39;</span><span class="p">,</span>
                            <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;val&#39;</span><span class="p">:</span><span class="n">cstruct</span><span class="p">})</span>
                          <span class="p">)</span>

<div class="viewcode-block" id="Integer"><a class="viewcode-back" href="../api.html#colander.Integer">[docs]</a><span class="k">class</span> <span class="nc">Integer</span><span class="p">(</span><span class="n">Number</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; A type representing an integer.</span>

<span class="sd">    If the :attr:`colander.null` value is passed to the serialize</span>
<span class="sd">    method of this class, the :attr:`colander.null` value will be</span>
<span class="sd">    returned.</span>

<span class="sd">    The subnodes of the :class:`colander.SchemaNode` that wraps</span>
<span class="sd">    this type are ignored.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">num</span> <span class="o">=</span> <span class="nb">int</span>
</div>
<span class="n">Int</span> <span class="o">=</span> <span class="n">Integer</span>

<div class="viewcode-block" id="Float"><a class="viewcode-back" href="../api.html#colander.Float">[docs]</a><span class="k">class</span> <span class="nc">Float</span><span class="p">(</span><span class="n">Number</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; A type representing a float.</span>

<span class="sd">    If the :attr:`colander.null` value is passed to the serialize</span>
<span class="sd">    method of this class, the :attr:`colander.null` value will be</span>
<span class="sd">    returned.</span>

<span class="sd">    The subnodes of the :class:`colander.SchemaNode` that wraps</span>
<span class="sd">    this type are ignored.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">num</span> <span class="o">=</span> <span class="nb">float</span>
</div>
<div class="viewcode-block" id="Decimal"><a class="viewcode-back" href="../api.html#colander.Decimal">[docs]</a><span class="k">class</span> <span class="nc">Decimal</span><span class="p">(</span><span class="n">Number</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; A type representing a decimal floating point.  Deserialization</span>
<span class="sd">    returns an instance of the Python ``decimal.Decimal`` type.</span>

<span class="sd">    If the :attr:`colander.null` value is passed to the serialize</span>
<span class="sd">    method of this class, the :attr:`colander.null` value will be</span>
<span class="sd">    returned.</span>

<span class="sd">    The subnodes of the :class:`colander.SchemaNode` that wraps</span>
<span class="sd">    this type are ignored.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">num</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="Boolean"><a class="viewcode-back" href="../api.html#colander.Boolean">[docs]</a><span class="k">class</span> <span class="nc">Boolean</span><span class="p">(</span><span class="n">SchemaType</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; A type representing a boolean object.</span>

<span class="sd">    During deserialization, a value in the set (``false``, ``0``) will</span>
<span class="sd">    be considered ``False``.  Anything else is considered</span>
<span class="sd">    ``True``. Case is ignored.</span>

<span class="sd">    Serialization will produce ``true`` or ``false`` based on the</span>
<span class="sd">    value.</span>

<span class="sd">    If the :attr:`colander.null` value is passed to the serialize</span>
<span class="sd">    method of this class, the :attr:`colander.null` value will be</span>
<span class="sd">    returned.</span>

<span class="sd">    The subnodes of the :class:`colander.SchemaNode` that wraps</span>
<span class="sd">    this type are ignored.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">appstruct</span> <span class="ow">is</span> <span class="n">null</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">null</span>

        <span class="k">return</span> <span class="n">appstruct</span> <span class="ow">and</span> <span class="s">&#39;true&#39;</span> <span class="ow">or</span> <span class="s">&#39;false&#39;</span>

    <span class="k">def</span> <span class="nf">deserialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">cstruct</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cstruct</span> <span class="ow">is</span> <span class="n">null</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">null</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">cstruct</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">node</span><span class="p">,</span>
                          <span class="n">_</span><span class="p">(</span><span class="s">&#39;${val} is not a string&#39;</span><span class="p">,</span> <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;val&#39;</span><span class="p">:</span><span class="n">cstruct</span><span class="p">})</span>
                          <span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">result</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;false&#39;</span><span class="p">,</span> <span class="s">&#39;0&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="k">return</span> <span class="bp">True</span>
</div>
<span class="n">Bool</span> <span class="o">=</span> <span class="n">Boolean</span>

<div class="viewcode-block" id="GlobalObject"><a class="viewcode-back" href="../api.html#colander.GlobalObject">[docs]</a><span class="k">class</span> <span class="nc">GlobalObject</span><span class="p">(</span><span class="n">SchemaType</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; A type representing an importable Python object.  This type</span>
<span class="sd">    serializes &#39;global&#39; Python objects (objects which can be imported)</span>
<span class="sd">    to dotted Python names.</span>

<span class="sd">    Two dotted name styles are supported during deserialization:</span>

<span class="sd">    - ``pkg_resources``-style dotted names where non-module attributes</span>
<span class="sd">      of a module are separated from the rest of the path using a &#39;:&#39;</span>
<span class="sd">      e.g. ``package.module:attr``.</span>

<span class="sd">    - ``zope.dottedname``-style dotted names where non-module</span>
<span class="sd">      attributes of a module are separated from the rest of the path</span>
<span class="sd">      using a &#39;.&#39; e.g. ``package.module.attr``.</span>

<span class="sd">    These styles can be used interchangeably.  If the serialization</span>
<span class="sd">    contains a ``:`` (colon), the ``pkg_resources`` resolution</span>
<span class="sd">    mechanism will be chosen, otherwise the ``zope.dottedname``</span>
<span class="sd">    resolution mechanism will be chosen.</span>

<span class="sd">    The constructor accepts a single argument named ``package`` which</span>
<span class="sd">    should be a Python module or package object; it is used when</span>
<span class="sd">    *relative* dotted names are supplied to the ``deserialize``</span>
<span class="sd">    method.  A serialization which has a ``.`` (dot) or ``:`` (colon)</span>
<span class="sd">    as its first character is treated as relative.  E.g. if</span>
<span class="sd">    ``.minidom`` is supplied to ``deserialize``, and the ``package``</span>
<span class="sd">    argument to this type was passed the ``xml`` module object, the</span>
<span class="sd">    resulting import would be for ``xml.minidom``.  If a relative</span>
<span class="sd">    package name is supplied to ``deserialize``, and no ``package``</span>
<span class="sd">    was supplied to the constructor, an :exc:`colander.Invalid` error</span>
<span class="sd">    will be raised.</span>

<span class="sd">    If the :attr:`colander.null` value is passed to the serialize</span>
<span class="sd">    method of this class, the :attr:`colander.null` value will be</span>
<span class="sd">    returned.</span>

<span class="sd">    The subnodes of the :class:`colander.SchemaNode` that wraps</span>
<span class="sd">    this type are ignored.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">package</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">package</span> <span class="o">=</span> <span class="n">package</span>

    <span class="k">def</span> <span class="nf">_pkg_resources_style</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; package.module:attr style &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">pkg_resources</span>
        <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">value</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;:&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">package</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span>
                    <span class="n">node</span><span class="p">,</span>
                    <span class="n">_</span><span class="p">(</span><span class="s">&#39;relative name &quot;${val}&quot; irresolveable without package&#39;</span><span class="p">,</span>
                      <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;val&#39;</span><span class="p">:</span><span class="n">value</span><span class="p">})</span>
                    <span class="p">)</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;.&#39;</span><span class="p">,</span> <span class="s">&#39;:&#39;</span><span class="p">]:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">package</span><span class="o">.</span><span class="n">__name__</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">package</span><span class="o">.</span><span class="n">__name__</span> <span class="o">+</span> <span class="n">value</span>
        <span class="k">return</span> <span class="n">pkg_resources</span><span class="o">.</span><span class="n">EntryPoint</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span>
            <span class="s">&#39;x=</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_zope_dottedname_style</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; package.module.attr style &quot;&quot;&quot;</span>
        <span class="n">module</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">package</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">package</span><span class="o">.</span><span class="n">__name__</span> <span class="ow">or</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="s">&#39;.&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">package</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span>
                    <span class="n">node</span><span class="p">,</span>
                    <span class="n">_</span><span class="p">(</span><span class="s">&#39;relative name &quot;${val}&quot; irresolveable without package&#39;</span><span class="p">,</span>
                      <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;val&#39;</span><span class="p">:</span><span class="n">value</span><span class="p">})</span>
                    <span class="p">)</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">module</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">module</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span>
                        <span class="n">node</span><span class="p">,</span>
                        <span class="n">_</span><span class="p">(</span><span class="s">&#39;relative name &quot;${val}&quot; irresolveable without &#39;</span>
                          <span class="s">&#39;package&#39;</span><span class="p">,</span> <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;val&#39;</span><span class="p">:</span><span class="n">value</span><span class="p">})</span>
                        <span class="p">)</span>
                <span class="n">module</span> <span class="o">=</span> <span class="n">module</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)</span>
                <span class="n">name</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">while</span> <span class="ow">not</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="n">module</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="n">name</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">module</span> <span class="o">+</span> <span class="n">name</span>

        <span class="n">used</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">found</span> <span class="o">=</span> <span class="nb">__import__</span><span class="p">(</span><span class="n">used</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
            <span class="n">used</span> <span class="o">+=</span> <span class="s">&#39;.&#39;</span> <span class="o">+</span> <span class="n">n</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">found</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">found</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span> <span class="c"># pragma: no cover</span>
                <span class="nb">__import__</span><span class="p">(</span><span class="n">used</span><span class="p">)</span>
                <span class="n">found</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">found</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">found</span>

    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">appstruct</span> <span class="ow">is</span> <span class="n">null</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">null</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">appstruct</span><span class="o">.</span><span class="n">__name__</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">node</span><span class="p">,</span>
                          <span class="n">_</span><span class="p">(</span><span class="s">&#39;&quot;${val}&quot; has no __name__&#39;</span><span class="p">,</span>
                            <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;val&#39;</span><span class="p">:</span><span class="n">appstruct</span><span class="p">})</span>
                          <span class="p">)</span>
    <span class="k">def</span> <span class="nf">deserialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">cstruct</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">cstruct</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">null</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cstruct</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">node</span><span class="p">,</span>
                          <span class="n">_</span><span class="p">(</span><span class="s">&#39;&quot;${val}&quot; is not a string&#39;</span><span class="p">,</span>
                            <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;val&#39;</span><span class="p">:</span><span class="n">cstruct</span><span class="p">}))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="s">&#39;:&#39;</span> <span class="ow">in</span> <span class="n">cstruct</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pkg_resources_style</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">cstruct</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zope_dottedname_style</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">cstruct</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">node</span><span class="p">,</span>
                          <span class="n">_</span><span class="p">(</span><span class="s">&#39;The dotted name &quot;${name}&quot; cannot be imported&#39;</span><span class="p">,</span>
                            <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;name&#39;</span><span class="p">:</span><span class="n">cstruct</span><span class="p">}))</span>
</div>
<div class="viewcode-block" id="DateTime"><a class="viewcode-back" href="../api.html#colander.DateTime">[docs]</a><span class="k">class</span> <span class="nc">DateTime</span><span class="p">(</span><span class="n">SchemaType</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; A type representing a Python ``datetime.datetime`` object.</span>

<span class="sd">    This type serializes python ``datetime.datetime`` objects to a</span>
<span class="sd">    `ISO8601 &lt;http://en.wikipedia.org/wiki/ISO_8601&gt;`_ string format.</span>
<span class="sd">    The format includes the date, the time, and the timezone of the</span>
<span class="sd">    datetime.</span>

<span class="sd">    The constructor accepts an argument named ``default_tzinfo`` which</span>
<span class="sd">    should be a Python ``tzinfo`` object; by default it is None,</span>
<span class="sd">    meaning that the default tzinfo will be equivalent to UTC (Zulu</span>
<span class="sd">    time).  The ``default_tzinfo`` tzinfo object is used to convert</span>
<span class="sd">    &#39;naive&#39; datetimes to a timezone-aware representation during</span>
<span class="sd">    serialization.</span>

<span class="sd">    You can adjust the error message reported by this class by</span>
<span class="sd">    changing its ``err_template`` attribute in a subclass on an</span>
<span class="sd">    instance of this class.  By default, the ``err_template``</span>
<span class="sd">    attribute is the string ``Invalid date``.  This string is used as</span>
<span class="sd">    the interpolation subject of a dictionary composed of ``val`` and</span>
<span class="sd">    ``err``.  ``val`` and ``err`` are the unvalidatable value and the</span>
<span class="sd">    exception caused trying to convert the value, respectively. These</span>
<span class="sd">    may be used in an overridden err_template as ``${val}`` and</span>
<span class="sd">    ``${err}`` respectively as necessary, e.g. ``_(&#39;${val} cannot be</span>
<span class="sd">    parsed as an iso8601 date: ${err}&#39;)``.</span>

<span class="sd">    For convenience, this type is also willing to coerce</span>
<span class="sd">    ``datetime.date`` objects to a DateTime ISO string representation</span>
<span class="sd">    during serialization.  It does so by using midnight of the day as</span>
<span class="sd">    the time, and uses the ``default_tzinfo`` to give the</span>
<span class="sd">    serialization a timezone.</span>

<span class="sd">    Likewise, for convenience, during deserialization, this type will</span>
<span class="sd">    convert ``YYYY-MM-DD`` ISO8601 values to a datetime object.  It</span>
<span class="sd">    does so by using midnight of the day as the time, and uses the</span>
<span class="sd">    ``default_tzinfo`` to give the serialization a timezone.</span>

<span class="sd">    If the :attr:`colander.null` value is passed to the serialize</span>
<span class="sd">    method of this class, the :attr:`colander.null` value will be</span>
<span class="sd">    returned.</span>

<span class="sd">    The subnodes of the :class:`colander.SchemaNode` that wraps</span>
<span class="sd">    this type are ignored.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">err_template</span> <span class="o">=</span>  <span class="n">_</span><span class="p">(</span><span class="s">&#39;Invalid date&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">default_tzinfo</span><span class="o">=</span><span class="n">_marker</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">default_tzinfo</span> <span class="ow">is</span> <span class="n">_marker</span><span class="p">:</span>
            <span class="n">default_tzinfo</span> <span class="o">=</span> <span class="n">iso8601</span><span class="o">.</span><span class="n">iso8601</span><span class="o">.</span><span class="n">Utc</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_tzinfo</span> <span class="o">=</span> <span class="n">default_tzinfo</span>

    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">appstruct</span> <span class="ow">is</span> <span class="n">null</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">null</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">appstruct</span><span class="p">)</span> <span class="ow">is</span> <span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">:</span> <span class="c"># cant use isinstance; dt subs date</span>
            <span class="n">appstruct</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">combine</span><span class="p">(</span><span class="n">appstruct</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">time</span><span class="p">())</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">appstruct</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">node</span><span class="p">,</span>
                          <span class="n">_</span><span class="p">(</span><span class="s">&#39;&quot;${val}&quot; is not a datetime object&#39;</span><span class="p">,</span>
                            <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;val&#39;</span><span class="p">:</span><span class="n">appstruct</span><span class="p">})</span>
                          <span class="p">)</span>

        <span class="k">if</span> <span class="n">appstruct</span><span class="o">.</span><span class="n">tzinfo</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">appstruct</span> <span class="o">=</span> <span class="n">appstruct</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">tzinfo</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">default_tzinfo</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">appstruct</span><span class="o">.</span><span class="n">isoformat</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">deserialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">cstruct</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">cstruct</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">null</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">iso8601</span><span class="o">.</span><span class="n">parse_date</span><span class="p">(</span>
                <span class="n">cstruct</span><span class="p">,</span> <span class="n">default_timezone</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">default_tzinfo</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">iso8601</span><span class="o">.</span><span class="n">ParseError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">),</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">year</span><span class="p">,</span> <span class="n">month</span><span class="p">,</span> <span class="n">day</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">cstruct</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;-&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="n">year</span><span class="p">,</span> <span class="n">month</span><span class="p">,</span> <span class="n">day</span><span class="p">,</span>
                                           <span class="n">tzinfo</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">default_tzinfo</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">_</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">err_template</span><span class="p">,</span>
                                      <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;val&#39;</span><span class="p">:</span><span class="n">cstruct</span><span class="p">,</span> <span class="s">&#39;err&#39;</span><span class="p">:</span><span class="n">e</span><span class="p">}))</span>
        <span class="k">return</span> <span class="n">result</span>
</div>
<div class="viewcode-block" id="Date"><a class="viewcode-back" href="../api.html#colander.Date">[docs]</a><span class="k">class</span> <span class="nc">Date</span><span class="p">(</span><span class="n">SchemaType</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; A type representing a Python ``datetime.date`` object.</span>

<span class="sd">    This type serializes python ``datetime.date`` objects to a</span>
<span class="sd">    `ISO8601 &lt;http://en.wikipedia.org/wiki/ISO_8601&gt;`_ string format.</span>
<span class="sd">    The format includes the date only.</span>

<span class="sd">    The constructor accepts no arguments.</span>

<span class="sd">    You can adjust the error message reported by this class by</span>
<span class="sd">    changing its ``err_template`` attribute in a subclass on an</span>
<span class="sd">    instance of this class.  By default, the ``err_template``</span>
<span class="sd">    attribute is the string ``Invalid date``.  This string is used as</span>
<span class="sd">    the interpolation subject of a dictionary composed of ``val`` and</span>
<span class="sd">    ``err``.  ``val`` and ``err`` are the unvalidatable value and the</span>
<span class="sd">    exception caused trying to convert the value, respectively. These</span>
<span class="sd">    may be used in an overridden err_template as ``${val}`` and</span>
<span class="sd">    ``${err}`` respectively as necessary, e.g. ``_(&#39;${val} cannot be</span>
<span class="sd">    parsed as an iso8601 date: ${err}&#39;)``.</span>

<span class="sd">    For convenience, this type is also willing to coerce</span>
<span class="sd">    ``datetime.datetime`` objects to a date-only ISO string</span>
<span class="sd">    representation during serialization.  It does so by stripping off</span>
<span class="sd">    any time information, converting the ``datetime.datetime`` into a</span>
<span class="sd">    date before serializing.</span>

<span class="sd">    Likewise, for convenience, this type is also willing to coerce ISO</span>
<span class="sd">    representations that contain time info into a ``datetime.date``</span>
<span class="sd">    object during deserialization.  It does so by throwing away any</span>
<span class="sd">    time information related to the serialized value during</span>
<span class="sd">    deserialization.</span>

<span class="sd">    If the :attr:`colander.null` value is passed to the serialize</span>
<span class="sd">    method of this class, the :attr:`colander.null` value will be</span>
<span class="sd">    returned.</span>

<span class="sd">    The subnodes of the :class:`colander.SchemaNode` that wraps</span>
<span class="sd">    this type are ignored.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">err_template</span> <span class="o">=</span>  <span class="n">_</span><span class="p">(</span><span class="s">&#39;Invalid date&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">appstruct</span> <span class="ow">is</span> <span class="n">null</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">null</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">appstruct</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">):</span>
            <span class="n">appstruct</span> <span class="o">=</span> <span class="n">appstruct</span><span class="o">.</span><span class="n">date</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">appstruct</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">node</span><span class="p">,</span>
                          <span class="n">_</span><span class="p">(</span><span class="s">&#39;&quot;${val}&quot; is not a date object&#39;</span><span class="p">,</span>
                            <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;val&#39;</span><span class="p">:</span><span class="n">appstruct</span><span class="p">})</span>
                          <span class="p">)</span>

        <span class="k">return</span> <span class="n">appstruct</span><span class="o">.</span><span class="n">isoformat</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">deserialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">cstruct</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">cstruct</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">null</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">iso8601</span><span class="o">.</span><span class="n">parse_date</span><span class="p">(</span><span class="n">cstruct</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">date</span><span class="p">()</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">iso8601</span><span class="o">.</span><span class="n">ParseError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">year</span><span class="p">,</span> <span class="n">month</span><span class="p">,</span> <span class="n">day</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">cstruct</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;-&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">(</span><span class="n">year</span><span class="p">,</span> <span class="n">month</span><span class="p">,</span> <span class="n">day</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">node</span><span class="p">,</span>
                              <span class="n">_</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">err_template</span><span class="p">,</span>
                                <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;val&#39;</span><span class="p">:</span><span class="n">cstruct</span><span class="p">,</span> <span class="s">&#39;err&#39;</span><span class="p">:</span><span class="n">e</span><span class="p">})</span>
                              <span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>
</div>
<div class="viewcode-block" id="Time"><a class="viewcode-back" href="../api.html#colander.Time">[docs]</a><span class="k">class</span> <span class="nc">Time</span><span class="p">(</span><span class="n">SchemaType</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; A type representing a Python ``datetime.time`` object.</span>

<span class="sd">    .. note:: This type is new as of Colander 0.9.3.</span>

<span class="sd">    This type serializes python ``datetime.time`` objects to a</span>
<span class="sd">    `ISO8601 &lt;http://en.wikipedia.org/wiki/ISO_8601&gt;`_ string format.</span>
<span class="sd">    The format includes the date only.</span>

<span class="sd">    The constructor accepts no arguments.</span>

<span class="sd">    You can adjust the error message reported by this class by</span>
<span class="sd">    changing its ``err_template`` attribute in a subclass on an</span>
<span class="sd">    instance of this class.  By default, the ``err_template``</span>
<span class="sd">    attribute is the string ``Invalid date``.  This string is used as</span>
<span class="sd">    the interpolation subject of a dictionary composed of ``val`` and</span>
<span class="sd">    ``err``.  ``val`` and ``err`` are the unvalidatable value and the</span>
<span class="sd">    exception caused trying to convert the value, respectively. These</span>
<span class="sd">    may be used in an overridden err_template as ``${val}`` and</span>
<span class="sd">    ``${err}`` respectively as necessary, e.g. ``_(&#39;${val} cannot be</span>
<span class="sd">    parsed as an iso8601 date: ${err}&#39;)``.</span>

<span class="sd">    For convenience, this type is also willing to coerce</span>
<span class="sd">    ``datetime.datetime`` objects to a time-only ISO string</span>
<span class="sd">    representation during serialization.  It does so by stripping off</span>
<span class="sd">    any date information, converting the ``datetime.datetime`` into a</span>
<span class="sd">    time before serializing.</span>

<span class="sd">    Likewise, for convenience, this type is also willing to coerce ISO</span>
<span class="sd">    representations that contain time info into a ``datetime.time``</span>
<span class="sd">    object during deserialization.  It does so by throwing away any</span>
<span class="sd">    date information related to the serialized value during</span>
<span class="sd">    deserialization.</span>

<span class="sd">    If the :attr:`colander.null` value is passed to the serialize</span>
<span class="sd">    method of this class, the :attr:`colander.null` value will be</span>
<span class="sd">    returned.</span>

<span class="sd">    The subnodes of the :class:`colander.SchemaNode` that wraps</span>
<span class="sd">    this type are ignored.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">err_template</span> <span class="o">=</span>  <span class="n">_</span><span class="p">(</span><span class="s">&#39;Invalid time&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">appstruct</span> <span class="ow">is</span> <span class="n">null</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">null</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">appstruct</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">):</span>
            <span class="n">appstruct</span> <span class="o">=</span> <span class="n">appstruct</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">appstruct</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">time</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">node</span><span class="p">,</span>
                          <span class="n">_</span><span class="p">(</span><span class="s">&#39;&quot;${val}&quot; is not a time object&#39;</span><span class="p">,</span>
                            <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;val&#39;</span><span class="p">:</span><span class="n">appstruct</span><span class="p">})</span>
                          <span class="p">)</span>

        <span class="k">return</span> <span class="n">appstruct</span><span class="o">.</span><span class="n">isoformat</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">deserialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">cstruct</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">cstruct</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">null</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">iso8601</span><span class="o">.</span><span class="n">parse_date</span><span class="p">(</span><span class="n">cstruct</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">iso8601</span><span class="o">.</span><span class="n">ParseError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">timeparse</span><span class="p">(</span><span class="n">cstruct</span><span class="p">,</span> <span class="s">&#39;%H:%M:%S&#39;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">timeparse</span><span class="p">(</span><span class="n">cstruct</span><span class="p">,</span> <span class="s">&#39;%H:%M&#39;</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">node</span><span class="p">,</span>
                                  <span class="n">_</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">err_template</span><span class="p">,</span>
                                    <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;val&#39;</span><span class="p">:</span><span class="n">cstruct</span><span class="p">,</span> <span class="s">&#39;err&#39;</span><span class="p">:</span><span class="n">e</span><span class="p">})</span>
                                  <span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>
</div>
<span class="k">def</span> <span class="nf">timeparse</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">format</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="o">*</span><span class="n">time</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">format</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="mi">6</span><span class="p">])</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

<div class="viewcode-block" id="SchemaNode"><a class="viewcode-back" href="../api.html#colander.SchemaNode">[docs]</a><span class="k">class</span> <span class="nc">SchemaNode</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fundamental building block of schemas.</span>

<span class="sd">    The constructor accepts these positional arguments:</span>

<span class="sd">    - ``typ`` (required): The &#39;type&#39; for this node.  It should be an</span>
<span class="sd">      instance of a class that implements the</span>
<span class="sd">      :class:`colander.interfaces.Type` interface.</span>

<span class="sd">    - ``children``: a sequence of subnodes.  If the subnodes of this</span>
<span class="sd">      node are not known at construction time, they can later be added</span>
<span class="sd">      via the ``add`` method.</span>

<span class="sd">    The constructor accepts these keyword arguments:</span>

<span class="sd">    - ``name``: The name of this node.</span>

<span class="sd">    - ``default``: The default serialization value for this node.</span>
<span class="sd">      Default: :attr:`colander.null`.</span>

<span class="sd">    - ``missing``: The default deserialization value for this node.  If it is</span>
<span class="sd">      not provided, the missing value of this node will be the special marker</span>
<span class="sd">      value :attr:`colander.required`, indicating that it is considered</span>
<span class="sd">      &#39;required&#39;.  When ``missing`` is :attr:`colander.required`, the</span>
<span class="sd">      ``required`` computed attribute will be ``True``.</span>

<span class="sd">    - ``preparer``: Optional preparer for this node.  It should be</span>
<span class="sd">      an object that implements the</span>
<span class="sd">      :class:`colander.interfaces.Preparer` interface.</span>

<span class="sd">    - ``validator``: Optional validator for this node.  It should be</span>
<span class="sd">      an object that implements the</span>
<span class="sd">      :class:`colander.interfaces.Validator` interface.</span>

<span class="sd">    - ``after_bind``: A callback which is called after a clone of this</span>
<span class="sd">      node has &#39;bound&#39; all of its values successfully. This callback</span>
<span class="sd">      is useful for performing arbitrary actions to the cloned node,</span>
<span class="sd">      or direct children of the cloned node (such as removing or</span>
<span class="sd">      adding children) at bind time.  A &#39;binding&#39; is the result of an</span>
<span class="sd">      execution of the ``bind`` method of the clone&#39;s prototype node,</span>
<span class="sd">      or one of the parents of the clone&#39;s prototype nodes.  The</span>
<span class="sd">      deepest nodes in the node tree are bound first, so the</span>
<span class="sd">      ``after_bind`` methods of the deepest nodes are called before</span>
<span class="sd">      the shallowest.  The ``after_bind`` callback should should</span>
<span class="sd">      accept two values: ``node`` and ``kw``.  ``node`` will be a</span>
<span class="sd">      clone of the bound node object, ``kw`` will be the set of</span>
<span class="sd">      keywords passed to the ``bind`` method.</span>

<span class="sd">    - ``title``: The title of this node.  Defaults to a titleization</span>
<span class="sd">      of the ``name`` (underscores replaced with empty strings and the</span>
<span class="sd">      first letter of every resulting word capitalized).  The title is</span>
<span class="sd">      used by higher-level systems (not by Colander itself).</span>

<span class="sd">    - ``description``: The description for this node.  Defaults to</span>
<span class="sd">      ``&#39;&#39;`` (the empty string).  The description is used by</span>
<span class="sd">      higher-level systems (not by Colander itself).</span>

<span class="sd">    - ``widget``: The &#39;widget&#39; for this node.  Defaults to ``None``.</span>
<span class="sd">      The widget attribute is not interpreted by Colander itself, it</span>
<span class="sd">      is only meaningful to higher-level systems such as Deform.</span>

<span class="sd">    Arbitrary keyword arguments remaining will be attached to the node</span>
<span class="sd">    object unmolested.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_counter</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="n">inst</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>
        <span class="n">inst</span><span class="o">.</span><span class="n">_order</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">_counter</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">inst</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">typ</span><span class="p">,</span> <span class="o">*</span><span class="n">children</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">=</span> <span class="n">typ</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">preparer</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;preparer&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">validator</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;validator&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;default&#39;</span><span class="p">,</span> <span class="n">null</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">missing</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;missing&#39;</span><span class="p">,</span> <span class="n">required</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;name&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raw_title</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;title&#39;</span><span class="p">,</span> <span class="n">_marker</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw_title</span> <span class="ow">is</span> <span class="n">_marker</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">title</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;_&#39;</span><span class="p">,</span> <span class="s">&#39; &#39;</span><span class="p">)</span><span class="o">.</span><span class="n">title</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">title</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw_title</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">description</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;description&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">widget</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;widget&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">after_bind</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;after_bind&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kw</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">children</span><span class="p">)</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="SchemaNode.required"><a class="viewcode-back" href="../api.html#colander.SchemaNode.required">[docs]</a>    <span class="k">def</span> <span class="nf">required</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; A property which returns ``True`` if the ``missing`` value</span>
<span class="sd">        related to this node was not specified.</span>

<span class="sd">        A return value of ``True`` implies that a ``missing`` value wasn&#39;t</span>
<span class="sd">        specified for this node or that the ``missing`` value of this node is</span>
<span class="sd">        :attr:`colander.required`.  A return value of ``False`` implies that</span>
<span class="sd">        a &#39;real&#39; ``missing`` value was specified for this node.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">missing</span><span class="p">,</span> <span class="n">deferred</span><span class="p">):</span>  <span class="c"># unbound schema with deferreds</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">missing</span> <span class="ow">is</span> <span class="n">required</span>
</div>
<div class="viewcode-block" id="SchemaNode.serialize"><a class="viewcode-back" href="../api.html#colander.SchemaNode.serialize">[docs]</a>    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">appstruct</span><span class="o">=</span><span class="n">null</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Serialize the :term:`appstruct` to a :term:`cstruct` based</span>
<span class="sd">        on the schema represented by this node and return the</span>
<span class="sd">        cstruct.</span>

<span class="sd">        If ``appstruct`` is :attr:`colander.null`, return the</span>
<span class="sd">        serialized value of this node&#39;s ``default`` attribute (by</span>
<span class="sd">        default, the serialization of :attr:`colander.null`).</span>

<span class="sd">        If an ``appstruct`` argument is not explicitly provided, it</span>
<span class="sd">        defaults to :attr:`colander.null`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">appstruct</span> <span class="ow">is</span> <span class="n">null</span><span class="p">:</span>
            <span class="n">appstruct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">appstruct</span><span class="p">,</span> <span class="n">deferred</span><span class="p">):</span> <span class="c"># unbound schema with deferreds</span>
            <span class="n">appstruct</span> <span class="o">=</span> <span class="n">null</span>
        <span class="n">cstruct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="o">.</span><span class="n">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cstruct</span>
</div>
<div class="viewcode-block" id="SchemaNode.flatten"><a class="viewcode-back" href="../api.html#colander.SchemaNode.flatten">[docs]</a>    <span class="k">def</span> <span class="nf">flatten</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create and return a data structure which is a flattened</span>
<span class="sd">        representation of the passed in struct based on the schema represented</span>
<span class="sd">        by this node.  The return data structure is a dictionary; its keys are</span>
<span class="sd">        dotted names.  Each dotted name represents a path to a location in the</span>
<span class="sd">        schema.  The values of of the flattened dictionary are subvalues of</span>
<span class="sd">        the passed in struct.&quot;&quot;&quot;</span>
        <span class="n">flat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">flat</span>
</div>
<div class="viewcode-block" id="SchemaNode.unflatten"><a class="viewcode-back" href="../api.html#colander.SchemaNode.unflatten">[docs]</a>    <span class="k">def</span> <span class="nf">unflatten</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fstruct</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create and return a data structure with nested substructures based</span>
<span class="sd">        on the schema represented by this node using the flattened</span>
<span class="sd">        representation passed in. This is the inverse operation to</span>
<span class="sd">        :meth:`colander.SchemaNode.flatten`.&quot;&quot;&quot;</span>
        <span class="n">paths</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">fstruct</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="o">.</span><span class="n">unflatten</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">paths</span><span class="p">,</span> <span class="n">fstruct</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="SchemaNode.set_value"><a class="viewcode-back" href="../api.html#colander.SchemaNode.set_value">[docs]</a>    <span class="k">def</span> <span class="nf">set_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">,</span> <span class="n">dotted_name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Uses the schema to set a value in a nested datastructure from a</span>
<span class="sd">        dotted name path. &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">,</span> <span class="n">dotted_name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="SchemaNode.get_value"><a class="viewcode-back" href="../api.html#colander.SchemaNode.get_value">[docs]</a>    <span class="k">def</span> <span class="nf">get_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">,</span> <span class="n">dotted_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Traverses the nested data structure using the schema and retrieves</span>
<span class="sd">        the value specified by the dotted name path.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">,</span> <span class="n">dotted_name</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="SchemaNode.deserialize"><a class="viewcode-back" href="../api.html#colander.SchemaNode.deserialize">[docs]</a>    <span class="k">def</span> <span class="nf">deserialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cstruct</span><span class="o">=</span><span class="n">null</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Deserialize the :term:`cstruct` into an :term:`appstruct` based</span>
<span class="sd">        on the schema, run this :term:`appstruct` through the</span>
<span class="sd">        preparer, if one is present, then validate the</span>
<span class="sd">        prepared appstruct.  The ``cstruct`` value is deserialized into an</span>
<span class="sd">        ``appstruct`` unconditionally.</span>

<span class="sd">        If ``appstruct`` returned by type deserialization and</span>
<span class="sd">        preparation is the value :attr:`colander.null`, do something</span>
<span class="sd">        special before attempting validation:</span>

<span class="sd">        - If the ``missing`` attribute of this node has been set explicitly,</span>
<span class="sd">          return its value.  No validation of this value is performed; it is</span>
<span class="sd">          simply returned.</span>

<span class="sd">        - If the ``missing`` attribute of this node has not been set</span>
<span class="sd">          explicitly, raise a :exc:`colander.Invalid` exception error.</span>

<span class="sd">        If the appstruct is not ``colander.null`` and cannot be validated , a</span>
<span class="sd">        :exc:`colander.Invalid` exception will be raised.</span>

<span class="sd">        If a ``cstruct`` argument is not explicitly provided, it</span>
<span class="sd">        defaults to :attr:`colander.null`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">appstruct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="o">.</span><span class="n">deserialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cstruct</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">preparer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">appstruct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">preparer</span><span class="p">(</span><span class="n">appstruct</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">appstruct</span> <span class="ow">is</span> <span class="n">null</span><span class="p">:</span>
            <span class="n">appstruct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">missing</span>
            <span class="k">if</span> <span class="n">appstruct</span> <span class="ow">is</span> <span class="n">required</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_</span><span class="p">(</span><span class="s">&#39;Required&#39;</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">appstruct</span><span class="p">,</span> <span class="n">deferred</span><span class="p">):</span> <span class="c"># unbound schema with deferreds</span>
                <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_</span><span class="p">(</span><span class="s">&#39;Required&#39;</span><span class="p">))</span>
            <span class="c"># We never deserialize or validate the missing value</span>
            <span class="k">return</span> <span class="n">appstruct</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">validator</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">validator</span><span class="p">,</span> <span class="n">deferred</span><span class="p">):</span> <span class="c"># unbound</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">validator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">appstruct</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">appstruct</span>
</div>
<div class="viewcode-block" id="SchemaNode.add"><a class="viewcode-back" href="../api.html#colander.SchemaNode.add">[docs]</a>    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Add a subnode to this node. &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="SchemaNode.clone"><a class="viewcode-back" href="../api.html#colander.SchemaNode.clone">[docs]</a>    <span class="k">def</span> <span class="nf">clone</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Clone the schema node and return the clone.  All subnodes</span>
<span class="sd">        are also cloned recursively.  Attributes present in node</span>
<span class="sd">        dictionaries are preserved.&quot;&quot;&quot;</span>
        <span class="n">cloned</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">)</span>
        <span class="n">cloned</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">)</span>
        <span class="n">cloned</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="p">[</span> <span class="n">node</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="p">]</span>
        <span class="k">return</span> <span class="n">cloned</span>
</div>
<div class="viewcode-block" id="SchemaNode.bind"><a class="viewcode-back" href="../api.html#colander.SchemaNode.bind">[docs]</a>    <span class="k">def</span> <span class="nf">bind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Resolve any deferred values attached to this schema node</span>
<span class="sd">        and its children (recursively), using the keywords passed as</span>
<span class="sd">        ``kw`` as input to each deferred value.  This function</span>
<span class="sd">        *clones* the schema it is called upon and returns the cloned</span>
<span class="sd">        value.  The original schema node (the source of the clone)</span>
<span class="sd">        is not modified.&quot;&quot;&quot;</span>
        <span class="n">cloned</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="n">cloned</span><span class="o">.</span><span class="n">_bind</span><span class="p">(</span><span class="n">kw</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cloned</span>
</div>
    <span class="k">def</span> <span class="nf">_bind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kw</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="n">child</span><span class="o">.</span><span class="n">_bind</span><span class="p">(</span><span class="n">kw</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">deferred</span><span class="p">):</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kw</span><span class="p">)</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;after_bind&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">after_bind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kw</span><span class="p">)</span>

<div class="viewcode-block" id="SchemaNode.__delitem__"><a class="viewcode-back" href="../api.html#colander.SchemaNode.__delitem__">[docs]</a>    <span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Remove a subnode by name &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[:]):</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">name</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="SchemaNode.__getitem__"><a class="viewcode-back" href="../api.html#colander.SchemaNode.__getitem__">[docs]</a>    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get a subnode by name. &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">name</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">node</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">newnode</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Replace a subnode by name &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[:]):</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">name</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">newnode</span>
                <span class="n">newnode</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
                <span class="k">return</span> <span class="n">node</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

<div class="viewcode-block" id="SchemaNode.__iter__"><a class="viewcode-back" href="../api.html#colander.SchemaNode.__iter__">[docs]</a>    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Iterate over the children nodes of this schema node &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;&lt;</span><span class="si">%s</span><span class="s">.</span><span class="si">%s</span><span class="s"> object at </span><span class="si">%d</span><span class="s"> (named </span><span class="si">%s</span><span class="s">)&gt;&#39;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__module__</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span>
            <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="p">)</span>
</div>
<span class="k">class</span> <span class="nc">_SchemaMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">clsattrs</span><span class="p">):</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">clsattrs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">SchemaNode</span><span class="p">):</span>
                <span class="n">value</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
                <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">raw_title</span> <span class="ow">is</span> <span class="n">_marker</span><span class="p">:</span>
                    <span class="n">value</span><span class="o">.</span><span class="n">title</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;_&#39;</span><span class="p">,</span> <span class="s">&#39; &#39;</span><span class="p">)</span><span class="o">.</span><span class="n">title</span><span class="p">()</span>
                <span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">value</span><span class="o">.</span><span class="n">_order</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">__schema_nodes__</span> <span class="o">=</span> <span class="n">nodes</span>
        <span class="c"># Combine all attrs from this class and its subclasses.</span>
        <span class="n">extended</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cls</span><span class="o">.</span><span class="n">__mro__</span><span class="p">:</span>
            <span class="n">extended</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="s">&#39;__schema_nodes__&#39;</span><span class="p">,</span> <span class="p">[]))</span>
        <span class="c"># Sort the attrs to maintain the order as defined, and assign to the</span>
        <span class="c"># class.</span>
        <span class="n">extended</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">extended</span><span class="p">]</span>

<div class="viewcode-block" id="Schema"><a class="viewcode-back" href="../api.html#colander.Schema">[docs]</a><span class="k">class</span> <span class="nc">Schema</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">schema_type</span> <span class="o">=</span> <span class="n">Mapping</span>
    <span class="n">node_type</span> <span class="o">=</span> <span class="n">SchemaNode</span>
    <span class="n">__metaclass__</span> <span class="o">=</span> <span class="n">_SchemaMeta</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="n">node</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">node_type</span><span class="p">)</span>
        <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">node</span><span class="o">.</span><span class="n">_order</span> <span class="o">=</span> <span class="n">SchemaNode</span><span class="o">.</span><span class="n">_counter</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
        <span class="n">typ</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">schema_type</span><span class="p">()</span>
        <span class="n">node</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">typ</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">cls</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="n">node</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">node</span>
</div>
<span class="n">MappingSchema</span> <span class="o">=</span> <span class="n">Schema</span>

<div class="viewcode-block" id="SequenceSchema"><a class="viewcode-back" href="../api.html#colander.SequenceSchema">[docs]</a><span class="k">class</span> <span class="nc">SequenceSchema</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">schema_type</span> <span class="o">=</span> <span class="n">Sequence</span>
    <span class="n">node_type</span> <span class="o">=</span> <span class="n">SchemaNode</span>
    <span class="n">__metaclass__</span> <span class="o">=</span> <span class="n">_SchemaMeta</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="n">node</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">node_type</span><span class="p">)</span>
        <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">node</span><span class="o">.</span><span class="n">_order</span> <span class="o">=</span> <span class="n">SchemaNode</span><span class="o">.</span><span class="n">_counter</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
        <span class="n">typ</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">schema_type</span><span class="p">()</span>
        <span class="n">node</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">typ</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">Invalid</span><span class="p">(</span><span class="n">node</span><span class="p">,</span>
                          <span class="s">&#39;Sequence schemas must have exactly one child node&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">cls</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="n">node</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">node</span>
</div>
<div class="viewcode-block" id="TupleSchema"><a class="viewcode-back" href="../api.html#colander.TupleSchema">[docs]</a><span class="k">class</span> <span class="nc">TupleSchema</span><span class="p">(</span><span class="n">Schema</span><span class="p">):</span>
    <span class="n">schema_type</span> <span class="o">=</span> <span class="n">Tuple</span>
</div>
<div class="viewcode-block" id="deferred"><a class="viewcode-back" href="../api.html#colander.deferred">[docs]</a><span class="k">class</span> <span class="nc">deferred</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; A decorator which can be used to define deferred schema values</span>
<span class="sd">    (missing values, widgets, validators, etc.)&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wrapped</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span> <span class="o">=</span> <span class="n">wrapped</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">kw</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">kw</span><span class="p">)</span>
</div>
<span class="k">def</span> <span class="nf">_unflatten_mapping</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">paths</span><span class="p">,</span> <span class="n">fstruct</span><span class="p">,</span>
                       <span class="n">get_child</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">rewrite_subpath</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">get_child</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">get_child</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">__getitem__</span>
    <span class="k">if</span> <span class="n">rewrite_subpath</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">rewrite_subpath</span><span class="p">(</span><span class="n">subpath</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">subpath</span>
    <span class="n">node_name</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span>
    <span class="n">prefix</span> <span class="o">=</span> <span class="n">node_name</span> <span class="o">+</span> <span class="s">&#39;.&#39;</span>
    <span class="n">prefix_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span>
    <span class="n">appstruct</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">subfstruct</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">subpaths</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">curname</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">path</span> <span class="o">==</span> <span class="n">node_name</span><span class="p">:</span>
            <span class="c"># flattened structs contain non-leaf nodes which are ignored</span>
            <span class="c"># during unflattening.</span>
            <span class="k">continue</span>
        <span class="k">assert</span> <span class="n">path</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">prefix</span><span class="p">),</span> <span class="s">&quot;Bad node: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">path</span>
        <span class="n">subpath</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">prefix_len</span><span class="p">:]</span>
        <span class="k">if</span> <span class="s">&#39;.&#39;</span> <span class="ow">in</span> <span class="n">subpath</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">subpath</span><span class="p">[:</span><span class="n">subpath</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">subpath</span>
        <span class="k">if</span> <span class="n">curname</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">curname</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">elif</span> <span class="n">name</span> <span class="o">!=</span> <span class="n">curname</span><span class="p">:</span>
            <span class="n">subnode</span> <span class="o">=</span> <span class="n">get_child</span><span class="p">(</span><span class="n">curname</span><span class="p">)</span>
            <span class="n">appstruct</span><span class="p">[</span><span class="n">curname</span><span class="p">]</span> <span class="o">=</span> <span class="n">subnode</span><span class="o">.</span><span class="n">typ</span><span class="o">.</span><span class="n">unflatten</span><span class="p">(</span>
                <span class="n">subnode</span><span class="p">,</span> <span class="n">subpaths</span><span class="p">,</span> <span class="n">subfstruct</span><span class="p">)</span>
            <span class="n">subfstruct</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">subpaths</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">curname</span> <span class="o">=</span> <span class="n">name</span>
        <span class="n">subpath</span> <span class="o">=</span> <span class="n">rewrite_subpath</span><span class="p">(</span><span class="n">subpath</span><span class="p">)</span>
        <span class="n">subfstruct</span><span class="p">[</span><span class="n">subpath</span><span class="p">]</span> <span class="o">=</span> <span class="n">fstruct</span><span class="p">[</span><span class="n">path</span><span class="p">]</span>
        <span class="n">subpaths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subpath</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">curname</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">subnode</span> <span class="o">=</span> <span class="n">get_child</span><span class="p">(</span><span class="n">curname</span><span class="p">)</span>
        <span class="n">appstruct</span><span class="p">[</span><span class="n">curname</span><span class="p">]</span> <span class="o">=</span> <span class="n">subnode</span><span class="o">.</span><span class="n">typ</span><span class="o">.</span><span class="n">unflatten</span><span class="p">(</span>
            <span class="n">subnode</span><span class="p">,</span> <span class="n">subpaths</span><span class="p">,</span> <span class="n">subfstruct</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">appstruct</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../index.html">ColanderAlchemy 0.1 documentation</a> &raquo;</li>
          <li><a href="index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, Stefano Fontanelli.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.2.
    </div>
  </body>
</html>